---
title: "TITLE"
author: "AUTHORS"
includes:
  in_header:
    - \usepackage{lmodern}
output:
  pdf_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    toc: yes
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    theme: journal
editor_options: 
  chunk_output_type: console
---

This code goes along with the eggVar project. The goal of this project was to determine the number of offspring an individual *T. castaneum* could produce over a 24 hour period in suitable habitat. 

```{r}

install.packages('igraph')
install.packages('plyr')
install.packages('dplyr')

# data manipulation libraries
library(igraph)
library(plyr)
library(dplyr)

```

```{r}
dat <- read.csv("eggVar_data.csv")

dat2 <- dat[,"numAdults"]
dat2 <- na.omit(dat2)

dat3 <- dat2[which(dat2 > 0)]

pdf("beetleDistribution.pdf", width = 10, height = 6)
eggHist <- hist(x = dat3, xlab = "Number of offspring", main = "", 
     ylim = c(0,40), xlim = c(0,170), breaks = seq(0, 170, 2), xaxt = "n")
axis(side = 1, at = eggHist$breaks, labels = eggHist$breaks)
abline(v = 16, col = "firebrick", lwd = 2)
dev.off()
```

```{r}
# use dat2 from above

#' Estimate growth rate from a distribution
#' @param offDist the distribution of offspring
#' @param sampNum the number of individuals 
#' @param popInitial the starting pop size
#' @param alp the carrying capacity
#' @return a list where one element is a vector of growth rates and the other is a vector of population sizes

getGrowth <- function(offDist, sampNum, popInitial, alp = 0.002){
  growthDist <- c()
  popSize <- c()
  tmpOff <- sample(offDist, size = sampNum, replace = TRUE, prob = NULL)
  for (i in 1:sampNum) {
    growthDist[i] <- log(tmpOff[i]/popInitial)
  }
  for (j in 1:sampNum) {
    births <- rpois(1, growthDist[j]*popInitial)
    survivors <- rbinom(1, births, exp(-1*((alp*popInitial))))
    popSize[j] <- survivors
  }

  return(list(growthDist, popSize))
}

growthRates1 <- getGrowth(dat2, 1000, 1)
growthRates10 <- getGrowth(offDist = dat2, sampNum = 1000, popInitial = 10)
growthRates100 <- getGrowth(dat2, 1000, 100)

makePlot <- function(x){
  myPlot <- plot(x = x[[1]], y = x[[2]], pch = 16, xlab = "Growth Rate", ylab = "Population Size")
  return(myPlot)
}


pdf("popSize_growth.pdf", width = 6, height = 6)
thePlot <- makePlot(growthRates10)
dev.off()


pdf("growthRate_histogram.pdf", width = 6, height = 6)
hist(x = growthRates100, xlab = "Growth rate of individuals", main = "",
     breaks = 30)
dev.off()

```


```{r}
popsizeVec <- (seq(10, 100, by = 5))


growthMat <- matrix(data = NA, nrow = 1000, ncol = length(popsizeVec))
colnames(growthMat) <- popsizeVec
for (i in 1:nrow(growthMat)) {
  for (j in 1:ncol(growthMat)) {
   tmp <- as.numeric(sum(sample(x = dat3, size = 10, replace = TRUE)))
   growth <- log(tmp/as.numeric(popsizeVec[j]))
   growthMat[i,j] <- growth
  }
}

xtmp <- rep(popsizeVec, each = nrow(growthMat))  
ytmp <- as.vector(growthMat)                   

pdf("growthRate_by_popSize.pdf", width = 6, height = 6)
plot(xtmp, ytmp,
     xlab = "Population Size",
     ylab = "Growth rate",
     pch = 19, col = "black",
     xlim = c(10, 100),
     ylim = c(0, 4))
abline(h = 1.29, col = 'red')
dev.off()
```


All functions documented in the following format

```{r}
 
#' Plot a linear fit within the bounds of the data, and insert fit stats into plot
#'
#' @param y a vector 
#' @param x a vector
#' @param	forceIntercept (default = NULL) what is the intercept value to use (useful 
#'   for relationships that need to be forced through origin
#' @param legPos position of the legend (which is the slope and p-value; default=NULL)
#'   other values are "topleft", "bottomleft", "topright", "bottomright".
#' @param justMod if TRUE, no segment is drawn, but the model object is returned
#' @param textCol color of line and text.
#' @param ... other graphical parameters taht will be handed to the lines function 
#'
#' @return nothing 
#'
#' @importFrom grDevices adjustcolor colorRampPalette
#' @importFrom graphics lines text
#' @importFrom stats cor lm na.omit predict
#'
#' @export

plotSegments <- function(y,x, 
	forceIntercept=NULL, legPos=NULL,
  justMod = FALSE, textCol=1, ...){
	if(is.null(forceIntercept)){
	  m <- lm(y~x)
	}else{
	  m <- lm(y ~ 0 + x)
    preds <- predict(m, 
      newdata=data.frame(x=c(min(x, na.rm=TRUE), max(x, na.rm=TRUE))))
    lines(y=preds, x=c(min(x, na.rm=TRUE), max(x, na.rm=TRUE)), 
      col=textCol, ...)
		return(m)
	}
  if(justMod){
    return(m)
  }else{
    lty <- ifelse(summary(m)[[4]][2,4] < 0.05, 1, 5)
    preds <- predict(m, 
      newdata=data.frame(x=c(min(x, na.rm=TRUE), max(x, na.rm=TRUE))))
    lines(y=preds, x=c(min(x, na.rm=TRUE), max(x, na.rm=TRUE)), 
      lty=lty, col=textCol, ...)
    b <- format(summary(m)$coefficients[2],digits=2)
    pee <- format(summary(m)$coefficients[8],digits=4)
    if(pee < 0.0001){
      p <- '< 0.0001'
    }else{
      p <- paste('= ', pee, sep='')
    }
    if(!is.null(legPos)){
      legend(legPos, xpd=TRUE, legend=bquote(beta==.(b)~';'~'p'~.(p)), 
        col=textCol, bty='n')
    }
  }
}


```

Another useful function

```{r}

#' make hexbinplot
#' 
#' @param x one of the variables to plot
#' @param y the other one!
#' @param colz colors!
#' @param nbin number of bins to group the data
#' @param ... other arguments handed to plot
#'
#' @return a hexbin plot

getHex <- function(x,y, colz=NULL, nbin=100,...){
  require(dplyr)
  require(hexbin)
  if(is.null(colz)){
    colz <- viridis::viridis
  }
  hex <- hexbin(x, y, xbins=nbin, ...)
  # divide counts by 2 since you previously doubled the pairwise comparisons
  hex@count <- hex@count / 2 
  plot(hex, colramp = colz)
  hex
}


```

A linear regression of random data

```{r}

y <- rnorm(1000)
x <- rnorm(1000)
x2 <- x * y * runif(1000)


mod <- glm(y ~ x + x2)

summary(mod)

```

```{r}

plot(y, x)
plotSegments(y,x, 
  legPos='bottomright', textCol='dodgerblue'
)

```

```{r}

sessionInfo()

```
